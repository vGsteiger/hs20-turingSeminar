\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}

\usepackage[english]{babel}

\usepackage[round,authoryear]{natbib}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[hyphens]{url}
\usepackage{graphicx}
\usepackage{float}
\restylefloat{table}

\usepackage{lipsum}

\let\oldquote\quote
\let\endoldquote\endquote
\renewenvironment{quote}[2][]
{\if\relax\detokenize{#1}\relax
	\def\quoteauthor{#2}%
	\else
	\def\quoteauthor{#2~---~#1}%
	\fi
	\oldquote}
{\par\nobreak\smallskip\hfill(\quoteauthor)%
	\endoldquote\addvspace{\bigskipamount}}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\author{Viktor Gsteiger \\ University of Basel \\ Matriculation Number: 18-054-700}
\title{Backus Naur form and its influence on programming languages}
\date{November 9, 2020 \\\ Seminar: 58826-01 - Turing Award Winners and Their Contributions}

\begin{document}

\maketitle

\begin{abstract}
	The contribution of Peter Naur to the programming language Algol 60 and his preliminary work in the discipline of programming language description was a milestone of great importance to the field of computer science and to the discipline of programming language design in particular. The simple but powerful Backus Naur form, an extension of Naur to the already existing Backus form, has proved to be the new standard in language description after its first use in the Algol 60 report. The design and logic behind Algol 60 proved to be the foundation on which a large subset of all programming languages still in use today has been built upon. Naur’s thinking ahead and in larger meta-questions rather than small technicalities have demonstrated to be fundamental for the strength of Algol based languages. Since the importance of Naur’s work, it is a worthwhile undertaking to restate the most important parts of Naur’s contribution to the discipline of programming language description, to Algol as well as his influence on the subject of compiler design. This report is aimed at bachelor level students of Computer Science and we hope to also appeal to a wider audience.
\end{abstract}

\newpage

\section{Introduction}
The content of this paper will present a fairly detailed review of the development of formal notations of languages. The main focus of the first half of the report will lie in the development leading up to the notation used in the Algol 60 report and the notation used in the report itself. The subsequent parts will establish the link between Naur's further contributions to the topic of formalization with applications like the Gier Algol Compiler and beyond. We then wrap up this report with the impact of Naur on the field of computer science in a wider sense.

\section{History of Formal Descriptions for Languages}
The goal of defining a language by a formal system of variables and rules to derive the language has been of interest to grammarians and mathematicians since the verge of civilization. Panini, a Sanskrit philologist and grammarian which has worked between the 6th and 4th century BCE had, according to the biography \textit{Panini} by \citet{bhate2002panini}, already described a notation structure for the language of Sanskrit. The topic however only became of importance in the west at the beginning of the 20th century. With the advance of activity in the development of new, artificial languages like Esperanto or Ido and especially the rapid advances in calculating machines and the first version of computers the need for more formal language descriptions arose. The advance of new technologies posed new challenges in human-machine as well as human-human interactions which first had to be resolved before the underlying technological advances could be made usable for a larger audience than scientists.

\subsection{Noam Chomsky's introduction of phrase-structure grammar}
\textit{Noam Chomsky}, an American linguist teaching at MIT combined the new interest from mathematicians and linguists in his teaching groups. Chomsky gave lectures to information technology students and combined past research on the topic of string rewriting rules and formalism to develop his theory of formal logical systems. His main idea was to define the grammar structure of English as a finite-state Markov process. A finite-state Markov process is a random operation on a linear representation where it is clearly specified what the possible available transitions are from each node to the next ones. To achieve this idea, \citet{1056813} introduced in his paper \textit{Three Models for Description of Language} a notation for the rewriting of strings according to grammar. A grammar can be viewed as a machine operating on strings and giving certain output to an input. Chomsky also defined several different levels of grammars that are used in theoretical computer science until today.

The importance of Chomsky’s work can not be understated, even though he was not the original inventor of the idea. He built upon work from other mathematicians in addition to computer scientists. Most notably \textit{Axel Thue} as well as \textit{Alan Turing}. From the perspective of this paper, it is of great importance to understand the concept of phrase-structure grammars. Those grammars are as defined by Chomsky finite-state Markov processes that produce languages.

Henceforth, Chomsky defined a language $L$ as a (finite or infinite) set of sentences of finite length. Furthermore, a string is defined as a concatenation of symbols of an Alphabet $A$. The Alphabet consists of a finite set of terminal symbols. A grammar, as formulated beforehand, is then defined as a device that produces all of the strings that are sentences of $L$. A properly formulated grammar should define unambiguously the set of grammatical sentences of the language it represents. This means that a sentence which is clearly part of the language should be handled by the grammar in a fixed and predetermined manner.

A phrase-structure grammar consists of a finite vocabulary $V_p$, a finite set of initial strings $E$ in $V_p$, and a finite set of rules $F$ of the shape $X \to Y$, where $X$ and $Y$ are strings in $V_p$. The rules are interpreted as an instruction to the grammar device where $X$ has to be rewritten by $Y$. So any $Y_i$ is formed from a $X_i$ by replacement of a single symbol of $X_i$ by some string. A derivable string from this language is a string that can be constructed by the rules $F$. A terminal string from this language is a string which is the last line of a derivation where there is no further string to be derived.

Following, we will introduce an example for a phrase structure grammar. The symbol "$\_$" in the example is introduced for concatenation and will be replaced in the terminal string by a space. The \# denominates a meta-linguistic symbol to determine the boundaries of the given string:

\begin{equation} \label{eq1}
	\begin{split}
		\sum &: \# Sentence \# \\
		F&: \\ Sentence &\to NP\_VP \\
		VP &\to Verb\_NP \\
		NP &\to \text{the man}, \\
		NP &\to \text{the book} \\
		Verb &\to \text{took}
	\end{split}
\end{equation}

A derivable and terminal string from this grammar would be "the man took the book".

Furthermore, an interesting elaboration of Chomsky was that a language consisting of basic sentences that are derived from terminal strings of a phrase-structure grammar and a set of optional transformation rules applied to these terminal strings may create a language similar to modern English. The distinction of generative rules of grammar and transformation rules, which are applied after generating the language may remind some of the way functions and similar constructs in programming languages work today. The insight of Chomsky provided researchers as well as people interested in the structure of formal notations an entry point for further discussions and developments.


\subsection{Backus's introduction of a formal programming language description}
\textit{John Backus}, an American Computer Scientist who received the ACM Turing award in 1977 for his contribution to the design of practical high-level programming systems and for publication of formal procedures for the specification of programming languages. The latter part is interesting in the scope of this report as Backus built upon the idea of Chomsky as he was familiar with Chomsky's work. Backus was also one of the most influential computer scientists working on the then newly established programming language \textit{International Algebraic Language} (IAL). \citet{Backus1959TheSA} authored the report \textit{The syntax and semantics of the proposed international algebraic language of the Zurich ACM-GAMM Conference} which was the defining paper of the programming language now known as Algol 58 which was a direct precursor to Algol 60 to which Peter Naur contributed substantially.

Therefore, Backus, with the knowledge of the power of phrase-structure grammars, introduced a meta-linguistic formula to formally describe the rules of the IAL. The meta-linguistic formula introduced by Backus was a reference language to describe the functions of the IAL on a meta-level which allows for later hardware implementation to only differ with regards to word length, overflow conditions, and the like. The main purpose of the reference language introduced by Backus was to be as precise as possible to allow different stakeholders of the language development to communicate in a common language.
\\
The syntax of the reference language introduced by Backus was the following:
\begin{itemize}
	\item Sequences of character symbols enclosed in "< >" are meta-linguistic variables whose values are strings of symbols,
	\item The marks ":$\equiv$" and "$or$" are meta-linguistic connectives,
	\item Any mark that is neither a variable nor a connective denotes itself,
	\item The combination of marks and/or variables signifies the combination of the strings denoted
\end{itemize} 

This is best illustrated by an example. The \_ is introduced for the combination of two marks and/or variables and will in the derivation ultimately be replaced by a space:

\begin{equation} \label{eq2}
	\begin{split}
		<sentence> &:\equiv<NP>\_<VP> \\
		<VP> &:\equiv<Verb>\_<NP > \\
		<NP> &:\equiv\text{the man}\_or\_\text{the book} \\
		<Verb> &:\equiv\text{took} \\
	\end{split}
\end{equation}

As one may observe, it is the same grammar used in the previous example (\ref{eq1}) and should show the power of the notation introduced by Backus. One notable difference to the notation used by Chomsky is that Backus introduced the mark $or$, however, every string in the Backus notation consisting an $or$ could easily be rewritten into one or more strings without using the connective. It is therefore relevant to note that the notation introduced by Backus is exactly as strong as the phrase-structure grammars. Due to the low relevance of the Algol 58 report and other issues regarding the notation it did not catch on to the wider field of computer science and would have almost been forgotten, even though the need for an easily understandable and strong notation was greater than ever.

\section{Programming language description, formalization and Algol 60}

\begin{quote}{Ludwig Wittgenstein}
	\begin{flushright}
		Was sich überhaupt sagen lässt, lässt \\ sich klar sagen; und wovon man nicht \\ reden kann, darüber muss man schweigen.
	\end{flushright}
\end{quote}

\subsection{The Biography of Peter Naur}
\textit{Peter Naur}, born 1928 in Denmark to a family of artists and business-minded parents, had an early interest involving astronomy. He was allowed to work at the local observatory even as a very young boy. Naur published his first scientific paper with 15 and he had attained many technical skills of mathematics early on from professional astronomers which took him on as a young prodigy. After finishing his astronomy degree in Copenhagen he was recommended to research at King's College, Cambridge where he focused on astronomy and the emerging field of computer science. Due to weather constraints, Naur had to divert his attention from astronomy and had more time to spend programming the Electronic Delay Storage Automatic Calculator (EDSAC). Peter Naur, used to do complicated computational calculations by hand concentrated his energy mostly on the limitations of the EDSAC such as the limited number range and other meta-questions. The stay at Cambridge would also be important for his later career as he got first-hand experience in programming and how to eliminate program mistakes. After leaving Cambridge, Naur researched at Harvard University and Princeton, where he learned the state of the art in computing. The now more established field of computer science would be the focus of Naur, who returned to Denmark in 1953. Subsequently, Naur received his Doctor of Philosophy in astronomy in 1957.

Henceforth, in 1959 Naur joined the computer center of Copenhagen Regnecentralen and was asked to participate in the development of an algorithmic programming language, later called ALGOL. Naur's contribution to ALGOL lay in selecting the right forms of description to define the language. This was in line with his subsequent research as he was more interested in the meta aspects of the language rather than a specific implementation. Naur's main concern was that the often overly formal reports led to a split between the industry and academia as the two interacted ever less due to different ideas on formalities and the proofs of algorithms. It was an important question for him to make the field of computer science comprehensible to a wider audience.

Naur also contributed to the establishment of computer science as an academic discipline in Denmark where he continued to advocate for an applied form of computer science not only for his students but also for the domain in general hereby opposing Dijkstra and Wirth structured programming agenda. Furthermore, Naur shaped the way computer science was practiced in Denmark as he set the focus on the science of data processes. The curriculum laid a great extend of importance on real-world applications and other fields of knowledge.

\subsection{Backus Naur Form}
The Backus Naur form was introduced and used by \citet{backus1960report} in the \textit{Report on the algorithmic language ALGOL 60} published in 1960. It was introduced as the reference language of the report. A reference language as defined by the report is the defining form of expression that is the basic reference and guide for compiler builders, for all hardware representations, for transliterating from the language used in the report to any appropriate hardware representation and should be used by the main publications concerning ALGOL itself. Furthermore, the reference language should allow for all characters to be determined by ease of mutual understanding and should not be determined by any hardware limitations, code notation, or pure mathematical notation. Therefore, the reference language should be understandable to both the wider public as well as special interest groups as compiler or hardware builders. 
\\
As the name Backus Naur form (BNF) already suggests was the form an extension of the previously introduced notation form by Backus.  Naur introduced the notation as Backus Normal form, however, it has since been renamed. Especially after \citet{knuth-ba} pointed out in his letter to the editor of the ACM communications \textit{Backus Normal Form vs. Backus Naur Form} that the designation normal form should be reserved for true normal forms, which refer to some sort of special representation that presents an object in a standard way as a mathematical expression. According to Knuth, who in the end coined the name Backus Naur Form, the BNF did have a reason for distinction from the Chomsky phrase-structure grammar as the syntax from Chomsky represents a production form, meaning a specific representation of rewrite rules, while the Backus Naur form has a quite different representation.
\\
The syntax of the Backus Naur form is described as follows and it is always also noted how it differs from the production form of Chomsky:

\begin{itemize}
	\item Sequences of character symbols enclosed in "<>" are meta-linguistic variables whose values are sequences of symbols, which is a difference from production form as there is a clearer distinction between terminal and non-terminal symbols.
	\item The marks "::$=$" and "$|$", the latter with the meaning or, are meta-linguistic connectives. The connective "$|$" groups together all alternatives of a production system and is introduced to make the notation more compact, while the connective "::$=$" separates left from right.
	\item Any mark that is neither a variable nor a connective denotes itself.
	\item The combination of marks and/or variables signifies the combination of the strings denoted.
	\item Full names indicating the meaning of the strings being defined are used for non-terminal symbols, which was quite different from the production form as well as from the previous form of Backus. This contribution, according to Knuth, is probably the most important from Naur to the notation as it made the notation more applicable and usable.
\end{itemize}
\newpage
An example of the notation being used in the Algol report is how an integer is defined in the Algol 60 report:

\begin{equation} \label{eq3}
	\begin{split}
	<\text{digit}> ::=&0|1|2|3|4|5|6|7|8|9 \\
	<\text{unsigned integer}> ::=&<\text{digit}>|<\text{unsigned integer}><\text{digit}> \\
	<\text{integer}> ::=&<\text{unsigned integer}>|+<\text{unsigned integer}>|\\&-<\text{unsigned integer}>
	\end{split}
\end{equation}

Although the BNF is recognized as one of Peter Naur's most influential contributions, Naur himself did not like the name Backus Naur form and continued to call it Backus normal form. The reason for this decision is not entirely known but we speculate that Naur thought his participation to the development of the form to be of minor importance compared with the contribution of Backus. Naur's improvement of the notation is also in line with his later research as he mostly focused on the undesirability of the notation and in selecting the right forms of description. 

Henceforth, the Backus Naur form has been adapted and altered for multiple uses and an extended version of the Backus Naur form remains employed by most programming languages nowadays. The notation proved to be essential for further language and compiler design. The clear vision and simplicity has remained and has allowed subsequent generations of computer scientists to work within the field of language design.
\\
An interesting quality of the Backus Naur form is also that with just some slight modification the form can describe itself. \citet{rohl1968note} has shown that in his text \textit{A note on Backus Naur form}. The goal of this was to allow compilers to accept the Backus Naur form as input for their design. The approach taken by Rohl was for the brackets to surround not the meta-linguistic variables but the basic symbols. This allows the Backus Naur form to describe the meta-linguistic formula themselves. The brackets are then a device for over-riding any meta-linguistic significance of the symbol they enclose. Rohl also introduced the "$.$" to signify concatenation to allow for better readability.
\\
The definition of the meta-linguistic formula goes as follows:
\begin{equation} \label{eq4}
\begin{split}
	\text{meta formula} ::=& \text{meta variable}.<::=>.\text{definiens} \\
	\text{definiens} ::=& \text{construction}.<|>.\text{definiens} | \text{construction} \\
	\text{construction} ::=& \text{component}.<.>.\text{construction} | \text{component} \\
	\text{component} ::=& \text{meta variable} | <<>.\text{symbol}.<>> \\
\end{split}
\end{equation}

This definition now allows for a more automatic compiler generation as proposed by \citet{brooker1963compiler} in the paper \textit{The compiler compiler} where they introduced a compiler, named \textit{compiler compiler}, that was able to generate compilers for a certain hardware architecture, then the Atlas computers, with the language specification for the compilers being a phrase-structure grammar. By defining the meta-linguistic formula themselves it would be possible to compile a compiler for Algol with the \textit{compiler compiler}.

\subsection{The Algol 60 Report}

The Algorithmic Language of 1960, short Algol 60, was an important step in the history of programming languages as it had introduced a lot of new aspects and formalized many older concepts to make them more applicable. Numerous other important programming languages have been developed with the concepts of Algol in mind with Simula, Pascal and most importantly C being the most widely used ones.

The work on Algol 60 started after several scientists, including Peter Naur, studied and worked on the \textit{Algol 58} report by \citet{baueralgol} where they defined an early version of Algol. Peter Naur, working at Regnecentralen alongside Jørn Jensen, found the original report to be inconsistent and unclear. Thus, they organized a conference in Copenhagen during the year 1959. From this conference, the foremost notable outcome was that Naur started the \textit{Algol Bulletin} to concentrate the international effort on Algol and to distribute the various ideas. This led to Naur being the leading European mind working on the Algol effort.

According to \citet{naur1968successes} in his talk \textit{Successes and failures of the ALGOL effort} which took place in 1968, ten years after the first version of Algol 58 was published, a strong understanding of languages as well as compiler problems led to a need for a sound, common programming language. Together with improvements in the United States on Fortran as well as the developments of the Amsterdam school which supplied powerful and general ideas about the central features of programming languages, there was the solid groundwork for an improved programming language. Furthermore, the development of Backus on the reference language provided a suitable notation for a formal description of the resulting language.

The resulting \textit{Report on the algorithmic language ALGOL 60} by \citet{backus1960report} defined the language Algol 60 in a mix of formal, Backus Naur form, and informal syntax. The influence of the report was wide and we will try to discuss some important developments of the language and its syntax description. Henceforth, the most important aspect of a programming language is the programming of computers, in which Algol was a partial success. As a core language with its formal description and the newly introduced nested function definition as well as a strong focus on the lexical scopes of methods, the language could provide the developers of the time with new and strong concepts for their work. However, the missing input and output facilities proved to be detrimental to a wider field of programming applications.

Furthermore, one aspect of the language which directly coincided with its rather formal notation was the publication of algorithms. The very non-ambivalent description of the language made it a favorite for the development of algorithms and allowed it to be used theoretically in many applications. A further aspect of importance was the progress on formal languages which has acted as a strong stimulus for compiler designers. However, according to Naur, this development could be seen from two sides and the over formalization would not help to draw in further interest from the public.

Consequently, the form of the description was of great interest to Naur and would prove to be the topic of his interest in his later work. Naur was mostly concerned regarding the comprehensibility of a language by human readers rather than computers. This was also why he as the sole editor tried to use about the same amount of a formal as well as an informal notation to describe the language. The mixture of both was important to Naur and he later even proposed that the report should have included a more informal introduction. Naur himself criticized his work on Algol 60 strongly. Even though he was content with the formal description of the language, he was not content with how the report was received by the larger public. The Algol 60 report, as said by Naur, was very hard on the uninitiated reader.

An example of the formal notation one may have a look at the definition of the basic symbols of Algol 60 as introduced by the \textit{Revised report on the algorithmic language ALGOL 60} by \cite{Backus1963RevisedRO}. The revised report does not differ in notation and consists of different error corrections at different parts of the report:
\\ \\
\textit{The reference language is built up from the following basic symbols:}
\begin{equation} \label{eq5}
\begin{split}
<\text{basic symbol}> ::=&<\text{letter}>|<\text{digit}>|<\text{logical value}>|<\text{delimiter}> \\
\end{split}
\end{equation}

Some problems in the documentation which \citet{naur1963documentation} later pointed out in his article \textit{Documentation Problems: Algol 60} were mostly in the reliance of language description on formal notations. However, even though the Backus Naur form helped in the documentation, it provided no safety against errors. Writing a report on a programming language, according to Naur, differed not substantially from any other form of communication and the integral part was that the description must be complete and unambiguous. It is therefore also important to stress that even though there has been substantial progress in constructing mechanical and formal metalanguages, the natural languages will always remain the ultimate metalanguage.

The effort in the Algol 60 report was thus not futile, however, the over formalization proved to be a thorn in the eyes of Naur and would be of particular interest to him in his further work. Generally, it can be said that the report and the corresponding language of Algol 60 demonstrated to be strongly influential, however, far from perfect. As stated before, Naur himself was only partially content with the result and mostly criticized the formalization which made the report and language harder to use for humans and especially beginners. He himself later, especially in his function as a professor, tried to make documentation as humanly understandable as possible and closely related to real-world applications. 

\subsection{Notes on Formalization}
Peter Naur's opinions on formalization in program development were twofold. Naur was on one side one of the influential co-creators of the most famous formal notation, on the other he was a strong opponent of overly formalizing programming languages. In his work, Naur always tried to use twofold notations. An informal one in the standard language used for human communication and a formal language. However, his interest in formal notation was mainly to provide informal notations with additional brevity and clarity. \cite{naur1994proof} examined the usage of formal and informal modes of expression in his paper \textit{Proof versus formalization} where he compared several proofs and their notation. Most notably, he compared the proof of an algorithm by Warshall from 1962. It can be generally said that his endeavor into formalization came after his effort on Algol 60 and mostly resulted from his teaching at the University of Copenhagen where he was a professor after 1969.

In essence, Naur showed in his comparison that the common doctrines related to proof and formalization were most probably false. Especially the claim that the usage of formal modes for proving algorithms and mathematical theorems prevent human errors have proven to be a very false claim. Proofs, according to Naur, have the purpose of conveying knowledge from the writer to the reader. If a proof is overly formal, this may result in the reader not being able to understand the proof as the normal mode of communication for most humans is informal.

Consequently, Naur even more strongly opposed to an over formalization in the mode of communication when it came to programming language description. \cite{naur1982formalization} proved in his paper \textit{Formalization in program development} that an over-for- malization is not only making the language less appealing for a wider audience but also that a forced formalization may be detrimental to the preciseness and clarity of description. Again, a formal mode should mostly be introduced for brevity and convenience. Naur especially made clear that the formal mode should not be regarded as an alternative to the informal mode but rather as a freely introduced part of the basic informal mode. Furthermore, every formal argument can be transcribed into an informal one but not the opposite. The formal mode is thus a subset of the informal mode rather than another, independent, set altogether. 

The over-promotion of formal notation, according to Naur, will likely be rather harmful to effective program development especially because the focus on the formal notation will lead authors to believe that there are no principles nor practices of good informal expression. Naur proposed that there should be certain conventions involved in the usage of formality. The conventions are that one should choose each specialized word to identify unmistakably a concept that is useful and relevant in the context, that one should introduce the concepts and designated word where they are used, and lastly that the same concept introduced must be referred to invariably by the same designation. Furthermore, every description of real matters must fundamentally be based in an informal mode.

The notation introduced in the Algol 60 report does, according to Naur, qualify to justify these rules and is thus a good case for a formal description rooted in an informal description. The description of the formal notation is a good illustration and consists of 16 lines of informal prose, one example of a meta-syntactic formula, and four examples of symbol sequences generated by it. It is thus also easy to read and to understand, which was another important point to Naur. Notation should be designed to make it easier for programmers to use the language and also to write better programs, it should not make the development process harder which would result in the language being used less.

\subsection{Checking operand types in the Gier Algol Compiler}
A notation is important for human-human communication, however, it is also important in the process of human-machine interaction. One case of this very direct human-machine interaction can be observed in the development of compilers where a language has to be made understandable to computers. Compilers translate the human-readable programming language into machine code which the computer can execute. Peter Naur was closely involved in the development of the Gier Algol compiler and he has introduced the operand type checking system into this compiler. The motivation behind an operand checking system is to allow the programmers to detect errors more efficiently and thus make the development process less time-consuming. 

The philosophy of error treatment in the Gier Algol compiler, as stated by \cite{naur1965checking} in the article \textit{Checking of operand types in ALGOL compilers}, is to not permit any program in which the compiler has detected an error to run. The compiler will try to suppress all secondary consequences of a detected error to continue to process the rest of the program. This results in the need to fully integrate the error detection with the translation process. There will be two levels of error checking with the first being a check if the delimiter structure of the source program is allowed according to the language definition and a second one to check for the compatibility of the declarations in the way they are used to form expressions and statements.

It is important to note that the first level of error detection can work with the description given by the Backus Naur form as it can check if the source code is a terminal and reachable string of the described grammar. The second error checking needs some additional logic. 

The problem of the second-level error checking is the following: Given source code and given a complete description of the types and kinds of identifiers (provided by the language description), check that the usage of the identifiers and source code usages conform to their descriptions.

The solution proposed by Naur was to use the Reverse Polish form, which is a form of evaluating arithmetic expressions by using a stack to hold the values of those operands that have not been operated upon yet. The stack can be described as follows:
\\
\begin{equation} \label{eq6}
	\begin{split}
		\textbf{array} \textit{ OPERAND STACK}[1:\textit{some upper limit}]\\
	\end{split}
\end{equation}
Furthermore, let us introduce an integer, \textit{LAST USED}, to denote the current top value of the stack. The evaluation rules of Reverse Polish form is to evaluate the expression from left to right in a strictly sequential form. When an operand is being encountered, place it on top of the stack by increasing \textit{LAST USED} by one and saving the operand in the \textit{OPERAND STACK} at position \textit{LAST USED}. When encountering an operator, operate and place the result on the stack again. Binary operators remove two items from the stack.

The form of Reverse Polish form employed in the operand checking in the Gier compiler makes usage of both an \textit{OPERAND STACK} as well as an \textit{OPERATOR STACK}. The logic of operand checking now is simply to apply the rules of Reverse Polish notation while each time an operator is placed on top of the stack, one operand may already be checked on compatibility as it is not necessary to have both operands for a binary operator.

An example of the evaluation of an expression and its corresponding declarations is the following:
\begin{equation} \label{eq7}
	\begin{split}
		&\textbf{Boolean} \textit{ a}; \textbf{ integer } \textit{b, d}; \textbf{ real } \textit{c};\\
		&\textit{a } \equiv \textit{ b - c = d}\\
	\end{split}
\end{equation}

The sequence of actions taken in checking the operand types may be best done in a snapshot as described by \cite{naur1966proof} in the article \textit{Proof of algorithms by general snapshots} where Naur provided a diagram to display the behavior of algorithms for proofs by taking a snapshot of the current state of the involved variables at certain predetermined points to compare the behavior of the algorithm with the theoretically expected behavior. We will present the behavior of the Reverse Polish form algorithm for operand checking applied in the Gier compiler by showing a snapshot of the algorithm after one input character got evaluated.
\\
\begin{table}[H]
	\centering
		\begin{tabular}{llll|ll|l|}
			\hline
			\multicolumn{1}{|l|}{Action} & \multicolumn{1}{l|}{Input}    & OPERATOR                      & STACK   & OPERAND & STACK & Output   \\ \hline
			\multicolumn{1}{|l|}{}       & \multicolumn{1}{l|}{}         & \multicolumn{1}{l|}{{[}1{]}}  & {[}2{]} & {[}1{]} &       &          \\ \hline
			\multicolumn{1}{|l|}{1}      & \multicolumn{1}{l|}{a}        & \multicolumn{1}{l|}{}         &         & bo      &       & a        \\ \hline
			\multicolumn{1}{|l|}{2}      & \multicolumn{1}{l|}{$\equiv$} & \multicolumn{1}{l|}{$\equiv$} &         &         &       &          \\ \hline
			\multicolumn{1}{|l|}{3}      & \multicolumn{1}{l|}{b}        & \multicolumn{1}{l|}{$\equiv$} &         & in      &       & b        \\ \hline
			\multicolumn{1}{|l|}{4}      & \multicolumn{1}{l|}{-}        & \multicolumn{1}{l|}{$\equiv$} & -       &         &       &          \\ \hline
			\multicolumn{1}{|l|}{5}      & \multicolumn{1}{l|}{c}        & \multicolumn{1}{l|}{$\equiv$} & -       & re      &       & c        \\ \hline
			\multicolumn{1}{|l|}{6}      & \multicolumn{1}{l|}{=}        & \multicolumn{1}{l|}{$\equiv$} &         & re      &       & -        \\ \hline
			& \multicolumn{1}{l|}{}         & \multicolumn{1}{l|}{$\equiv$} & =       &         &       &          \\ \hline
			\multicolumn{1}{|l|}{7}      & \multicolumn{1}{l|}{d}        & \multicolumn{1}{l|}{$\equiv$} & =       & in      &       & d        \\ \hline
			\multicolumn{1}{|l|}{8}      & \multicolumn{1}{l|}{,}        & \multicolumn{1}{l|}{$\equiv$} &         & bo      &       & =        \\ \hline
			&                               &                               &         & bo      &       & $\equiv$ \\ \cline{5-7} 
		\end{tabular}
	\caption{Sequence of Operand type checking}
	\label{tab:my-table}
\end{table}

Each time an operand gets evaluated, its value gets put into the \textit{OPERAND STACK}, each time an operator gets evaluated, the top operand type gets checked and removed from the \textit{OPERAND STACK} while the operator goes on the \textit{OPERATOR STACK}, furthermore, every time a new operator gets evaluated, it gets checked if an operator may be unstacked. This happens for example when = is the current input and - gets evaluated with the current top operand. This unstacking is done for the operators on top of the \textit{OPERATOR STACK} where every operator on the stack gets compared with the current input operator until there is an operator on the stack with less priority than the input operator. Every operator that is unstacked will be placed in the output and the top operand gets checked against it.

The logic applied in the Reversed Polish form in the Gier Algol compiler also extends to all other Algo 60 delimiters like for example \textbf{then}. Every time an error gets detected, the internal operand class, \textit{UNDECLARED}, replaces the current operand and an error message is given.

The operand checking in the Gier Algol compiler is a good example of how a good operand definition of a language coupled with robust algorithms can be coupled to implement a strong error detection which then helps the human programmers to develop software faster. It is also a good illustration of how a formal language definition is beneficial to the compiler designers as it makes their job clear cut and the edge cases in this example can clearly be handled within the constraints of the language.
\newpage
\section{Conclusion and Peter Naur's Further Work}
Peter Naur has been both an advocate of formalization as well as a strong opponent of over-formalization. His influence can be seen in the Algol 60 report as well as in the subsequent development of programming languages. Most programming languages up to today use some extended form of the Backus Naur form in their language specification. Even though Naur himself did not want to be so closely associated with the notation, he did have a strong influence on the design and content of the Algol report. His philosophy of conveying theories rather than brute force information can also be observed in the article \textit{Programming as theory building} from \cite{naur1985programming} where he pointed out that the designers' job is not to pass along the design of a program but rather the theories driving the design. The primary job of a programmer is thus to build up knowledge. This philosophy can already be observed in Naur's early work where the documentation seemed to always place more importance on the wider concept than technical details. The description of Algol 60 for example made it such a substantial programming language exactly because it was rather a theory conveying than focusing on the technical details of its implementation.

Furthermore, Naur influenced the discipline of language description and therefore the future of compiler design by providing not only a good notation to be used by the designers but also by his human-first approach to the field of computer science. The idea of descriptive documents to him was always to allow humans to understand it better and he observed early on that for a language and its system to flourish it must be accessible to many more people than just a small part of academia. \cite{naur2007computing} further displayed this interest in human understanding in his acceptance speech of the ACM's 2005 A.M. Turing Award \textit{Computing Versus Human Thinking} where he displayed a deep engagement in human understanding and the complex processes of thinking. Not only could Naur be considered a computer scientist but also a philosopher, psychologist, and linguist. Naur can be identified as a supporter of the empiricist school of thought which can be seen in his work as he is concerned mostly about the observable and describable rather than seek deeper connections between things. His fundamental contribution to the field of computer science is vast and the influence of his work can be observed until today for example in form of a larger audience being able to participate and the humanist approach used in most educational courses and literature nowadays and beyond.
\newpage
\bibliographystyle{apalike}
\bibliography{references}
\end{document}
