\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}

\usepackage[english]{babel}

\usepackage[round,authoryear]{natbib}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[hyphens]{url}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{hyperref}

\restylefloat{table}

\usepackage{lipsum}

\let\oldquote\quote
\let\endoldquote\endquote
\renewenvironment{quote}[2][]
{\if\relax\detokenize{#1}\relax
	\def\quoteauthor{#2}%
	\else
	\def\quoteauthor{#2~---~#1}%
	\fi
	\oldquote}
{\par\nobreak\smallskip\hfill(\quoteauthor)%
	\endoldquote\addvspace{\bigskipamount}}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\author{Viktor Gsteiger \\ University of Basel \\ Matriculation Number: 18-054-700}
\title{Turing project: ALGOL 60 Tutorial}
\date{November 21, 2020 \\\ Seminar: 58826-01 - Turing Award Winners and Their Contributions}

\begin{document}

\maketitle

\begin{abstract}
	The difficulty of learning a new programming language is inherently great. One may have no previous experience all together, one may have some experience but with another language or one may have some knowledge about the language at hand but may have forgotten large parts of the learn things again. The difficulty of learning a programming language that is not used any more and never had great commercial success is even greater, however, in the case of ALGOL 60, I am convinced, that the effort is not without benefits. ALGOL 60 is one of the grandparents of most modern programming languages and thus a direct predecessor of the tools we use every day. It is thus important to study the roots of our tools, to learn from past experiences and correct past mistakes.
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Introduction}
This tutorial aims to give the reader an introduction into the ALGOL 60 programming language. The reader should be able to program small to mid size procedures after reading this tutorial and should be able to translate and execute the ALGOL 60 program with the help of the marst translator. This tutorial does not aim to be complete and due to the inherent difficulty of learning a programming language it does not aim to lead to success.

\section{Background}
ALGOL 60 was the direct successor of the International Algebraic Language (IAL or later called ALGOL 58) and was a joint effort of European as well as American computer scientists in the years 1958 to 1960. With the help of the ALGOL Bulletin, a publication edited by Peter Naur, and several conferences the ALGOL 60 report could be published in 1960. ALGOL 60 did not have great commercial success on its own, however, the concepts introduced by the language can be witnessed in programming languages until nowadays.

The GNU marst translator translates programs written in ALGOL 60 into the ANSI C 89 programming language. It is part of the GNU project and currently maintained by Andrew Makhorin and the last release dates back to 2013.

\section{ALGOL 60 Environment Setup}
Before we can start programming in ALGOL 6, we will need to install some prerequisites to edit, translate and execute ALGOL 60 programs.

\subsection{Text Editor}
To edit any kind of text document, one will need a text editor. Examples include Windows Notepad, vim, EMACS, Atom or similar text editors. 

The files created with the text editor are source files with ALGOL 60 programs usually having the extension ".alg".

\subsection{The C Compiler}
The C Compiler translates the human readable source code into executable machine language. In the case of writing ALGOL 60 programs the C Compiler is not directly accessed by the user but rather compiles the translated ALGOL 60 program into machine code. 

The C Compiler usually used is the GNU C/C++ compiler. In the following subsection I will discuss on how to install the C compiler on the UNIX based Operating Systems. It is sadly not possible for me to install it on Microsoft Windows and thus I will focus on the UNIX based OS.

\subsection{C Compiler Installation}

\subsubsection{Installation on UNIX}
The GNU C/C++ compiler is mostly already installed on UNIX systems. To check whether the compiler is already install type the following into the command line:

\begin{lstlisting}[]
$ gcc -v
\end{lstlisting}

If the GNU compiler is already installed then something like the following will be printed out to the command line:

\begin{lstlisting}[]
Using built-in specs. 
Target: i386-redhat-linux 
Configured with: ../configure --prefix=/usr ....... 
Thread model: posix 
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
\end{lstlisting}

If the GNU compiler is not installed on your UNIX system you will need to install it from an official GNU distribution. See the documentation on the \href{http://gcc.gnu.org/install/}{download page} for reference.

\subsubsection{Installation on Mac OS}
The easiest way to install the GNU compiler on a Mac OS X is to install the Xcode development environment provided by Apple. See the documentation on the \href{https://developer.apple.com/xcode/}{download page} for reference.

This tutorial has been written based on Mac OS and the examples have been translated and compiled on Catalina.

\subsection{ALGOL 60 Translator Installation}
The marst ALGOL 60 translator can be downloaded from any \href{https://www.gnu.org/prep/ftp.html}{gnu mirror} under \texttt{/gnu/marst/}. We will be using version 2.7 or marst released in 2013. Download the tar directory and uncompress it.

To install marst on your OS type the following into the command line at the location of the \texttt{marst-2.7} directory:

\begin{lstlisting}[]
$ ./configure; make; make install
\end{lstlisting}

This should configure, build, and install the marst package. For more information see the \texttt{README} or the \texttt{INSTALL} file.

\section{ALGOL 60 Program Structure}
Before we introduce the building blocks involved in developing an ALGOL 60 program we will introduce an example ALGOL 60 program and its structure so that we may use it again for reference in the following sections.

\subsection{ALGOL 60 Hello World Example}
An ALGOL 60 program can be constructed with the following parts:

\begin{itemize}
	\item Procedures
	\item Variables
	\item Statements
	\item Comments
\end{itemize}

A simple example to display various parts of an ALGOL 60 program would be the following:

\begin{lstlisting}[]
procedure main();
	comment a first ALGOL 60 program
	begin
		outstring(1, "Hello, world!\n")
	end
end main;

main();
\end{lstlisting}

The parts of the above program are the following:

\begin{enumerate}
	\item The first line declares the procedure which we called the main procedure. The name of the procedure can be changed.
	\item The next line is a comment which will be ignored by the translator and is used to comment on the code at hand to make it easier for fellow programmers to understand the intention of the program.
	\item The \texttt{begin} keyword signifies that a block of the procedure starts here.
	\item Following comes an output keyword \texttt{outstring} which displays the string given to the first  output channel.
	\item The last line calls the main procedure and executes it with it.
\end{enumerate}

\subsection{Compile and Execute an ALGOL 60 Program}
We will now save the ALGOL 60 program, translate it, compile it, and run it. The steps to do this are the following:

\begin{enumerate}
	\item Open your text editor and type in the above program.
	\item Save the file as \texttt{hello.alg}.
	\item Open a command line and navigate to the directory where the above program has been saved.
	\item Type \texttt{marst hello.alg -o hello.c}.
	\item If there are no errors the translator creates the C file \texttt{hello.c}.
	\item Compile and link the file with the following command \texttt{gcc hello.c -lalgol -lm -o hello}.
	\item Run your executable \texttt{./hello}.
	\item If everything worked fine you should see \texttt{"Hello, world!"} printed on the command line.
\end{enumerate}

\section{ALGOL 60 Basic Syntax}

\subsection{Formal Notation}
The notation used in this part of the tutorial is the Backus Naur form also used in the original AGLOL 60 report. The notation is best explained with an example:\\

\begin{equation} \label{eq1}
\begin{split}
<\text{ab}> ::=&( |<\text{ab}>(|\text{example}|)  \\
\end{split}
\end{equation}

Where the sequence of character enclosed in brackets represent meta-linguistic variables which are represented by a sequence of symbols. The ::= and | signify meta-linguistic connectives. | has the meaning or. Any symbol in a formula that is neither a variable nor a connective denotes itself. Variables can be replaced with their own definition. So the example signifies a recursive rule for the formation of values of the variable <ab>. Some values for <ab> are:\\
example( or )((

\subsection{Symbols}
The basic symbols of the ALGOL 60 programming language consists of letters, digits, logical values, and delimiters. With the basic symbols of ALGOL 60 every ALGOL 60 program can be created. The basic symbols themselves have no semantic values and are combined together to create every program. The basic symbols are made up as follows: \\

\subsubsection{Letters}
\begin{equation} \label{eq1}
\begin{split}
<\text{digit}> ::=&a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|\\&A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z \\
\end{split}
\end{equation}
Which are used for forming identifiers and strings.

\subsubsection{Digits}
\begin{equation} \label{eq2}
\begin{split}
<\text{digit}> ::=&0|1|2|3|4|5|6|7|8|9 \\
\end{split}
\end{equation}
Which are used for forming numbers, identifiers and strings.

\subsubsection{Logical values}
\begin{equation} \label{eq3}
\begin{split}
<\text{logical values}> ::=&\textbf{true}|\textbf{false} \\
\end{split}
\end{equation}
Which have a set meaning as boolean logical values.

\subsubsection{Delimiters}
\begin{equation} \label{eq4}
\begin{split}
<\text{delimiter}> ::=&<\text{operator}>|<\text{separator}>|<\text{bracket}>|<\text{declarator}>|\\&<\text{specificator}> \\
<\text{operator}> ::=&<\text{arithmetic operator}>|<\text{relational operator}>|\\&<\text{logical operator}>|<\text{sequential operator}> \\
<\text{arithmetic operator}> ::=&+|-|*|/|\%|^** \\
<\text{relational operator}> ::=&<|<=|=|>=|>|!= \\
<\text{logical operator}> ::=&==|->(\text{meaning }\supset)||(\text{meaning or})|\&|!\\
<\text{sequential operator}> ::=&\textbf{go to}|\textbf{if}|\textbf{then}|\textbf{else}|\textbf{for}|\textbf{do}\\
<\text{separator}> ::=&,|.|\#|:|;|:=|\textbf{step}|\textbf{until}|\textbf{while}|\textbf{comment}\\
<\text{bracket}> ::=&\text{(}|\text{)}|\text{[}|\text{]}|\text{"}|\textbf{begin}|\textbf{end}\\
<\text{declarator}> ::=&\textbf{own}|\textbf{Boolean}|\textbf{integer}|\textbf{real}|\textbf{array}|\textbf{switch}|\textbf{procedure}\\
<\text{specificator}> ::=&\textbf{string}|\textbf{label}|\textbf{value}\\
\end{split}
\end{equation}
All delimiters have a fixed meaning for which is mostly obvious, or else the meaning will be explained at the appropriate section.\\
Typographical features such as blank spaces can be inserted between symbols, however, multi-character symbols should contain no blank space.\\
The separator \textbf{comment} has special importance and has the purpose of writing symbols into the code that will not be translated into machine executable code. The commenting symbols are all symbols between the separator \textbf{comment} and the separator ;.


\subsection{Identifiers}
In ALGOL 60 an identifier has no inherent meaning, but serve the identification of variables, arrays, labels, switches and procedures. An identifier starts with a letter and is followed by zero or more letters or digits. Every combination is allowed except the previously defined delimiters. Some examples for identifiers are as follows:\\

\begin{lstlisting}[]
Soup
V17a
MARILYN
\end{lstlisting}

\subsection{Numbers} \label{numbers}
Numbers are used for arithmetic operations. There are two types of numbers in the ALGOL 60 programming language. Both have the same functionalities, however different ranges of size. The types of numbers are \textbf{integer} and \textbf{real}. Integers are any positive or negative combination of digits. Reals are any integer including a decimal fraction and/or an exponent part (denoted by the symbol \#). More on this in the section \nameref{datatypes}. Some examples for numbers are as follows:\\

\begin{lstlisting}[]
0
.5384
-.083#-02
\end{lstlisting}

\subsection{Strings}
A string is any sequence of basic symbols not containing ". Strings are used as actual parameters of procedure, for example also the procedure \texttt{outstring} which has been included into the translation program for output functionalities. Due to the translation to a C program the strings may be coded as usual in C fashion. Escape sequences like \textbackslash n are allowed. To use double quote in a string use a backslash \textbackslash". Some examples for strings are as follows:\\

\begin{lstlisting}[]
"This is a string"
"This is another \"string\""
\end{lstlisting}


\section{ALGOL 60 Data Types} \label{datatypes}
As the original ALGOL 60 document was written without a specific hardware implementation in mind the ALGOL 60 data types used in this tutorial will reflect the C language data types in sizes. Data types define how much space will be occupied in storage.

\subsection{Integer Types}
As mentioned in subsection \nameref{numbers} integers refer to any positive or negative concatenation of numbers without any exponent or decimal fractions. The values possible are between \texttt{-32'768} to \texttt{32'768} if int is stored in 2 bytes or between \texttt{-2,147,483,648} to \texttt{2,147,483,647} if int is stored in 4 bytes. To get the exact possible size of the integer write a short program as follows:

\begin{lstlisting}[]
inline("printf(sizeof(int));")
\end{lstlisting}

The inline procedure is a pseudo procedure implemented by the MARST developers to signify what code will be one to one translated into C code.

\subsection{Real Types}
Again, as mentioned in subsection \nameref{numbers} reals refer to any positive concatenation of digits which may include exponents and/or decimal fractions. The values possible are between \texttt{1.2E-38} to \texttt{3.4E+38} with a precision to 6 decimal places if float is stored in 4 bytes

\section{ALGOL 60 Expressions}
The main constituents of any ALGOL 60 programs describing algorithmic processes are arithmetic, Boolean, and designational, expressions. These expressions contain logical values, numbers, variables, function designators, and operators.

\subsection{Variables}
A variable represents a single values. This value can be used in expressions and can be used to form other values and may be changed by means of assignment statements. Array expressions with their identifiers are also considered variables. The identifiers of arrays are enclosed in subscript brackets []. The type of a variable is defined in the declaration of the variable itself (see \nameref{typeDecl} for more information on types) or for the array identifier (see \nameref{arrayDecl} for more information on arrays). Examples for variables are as follows:

\begin{lstlisting}[]
beta
Q[7, 2]
a17
\end{lstlisting}

\subsection{Function designators}
A function designator represents a single value that can be attained by the application of a given set of rules defined by a procedure declaration (see \nameref{procDecl} for more information on procedures) to a defined set of parameters which can either be single values or variables. Examples for function desigantors are as follows:

\begin{lstlisting}[]
Compile("Test")Stack:(P)
J(1+s, n)
Rhesus
\end{lstlisting}

\subsection{Arithmetic expressions}


\section{ALGOL 60 Statements}

\subsection{Assignment Statement}

\subsection{Go To Statement}

\subsection{Conditional Statement}

\subsection{For Statement}

\subsection{Procedure Statement}

\section{ALGOL 60 Declarations}

\subsection{Type Declaration} \label{typeDecl}

\subsection{Array Declaration} \label{arrayDecl}

\subsection{Switch Declaration}

\subsection{Procedure Declaration} \label{procDecl}

\subsection{Variable Declaration}

\section{Procedures}

\subsection{Declarations}

\section{ALGOL 60 Scope Rules}

\section{Simple Programs}

\section{Recursion}

\end{document}
